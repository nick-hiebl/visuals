<title>Minimal Spanning Tree</title>
<div style="max-width: 100%; width: 1204px; margin: auto">
    <canvas id="kruskal" width="600" height="600"></canvas>
    <canvas id="prim" width="600" height="600"></canvas>
</div>
<script type="text/javascript" src="../visual.js"></script>
<script type="text/javascript" src="setup.js"></script>
<script type="text/javascript" src="kruskal.js"></script>
<script type="text/javascript" src="prim.js"></script>
<div style="min-width: 400px; margin: auto; width: 50%">
    <p>The two respective panels show:</p>
    <ul>
        <li>
            A Kruskal's approach to finding an MST.
        </li>
        <li>
            A Prim's approach to finding an MST.
        </li>
    </ul>
    <p>
        It's worth noting that this is a poor indicator of the relative
        speeds of each algorithm. I've allowed very different operations
        per frame in each algorithm purely for demonstration purposes.
        In each frame the Kruskal's algorithm simply considers one edge
        in its edgelist. On the other hand Prim's only looks at a single
        non-connected node to see if it is closer than any other node it
        has seen so far. This seems somewhat fair at face value, but
        Kruskal's has already had an incredibly costly sort applied to
        its edgelist and has a very heavy memory usage, as it must store
        every single edge in the graph and then sort it.
    </p>
    <p>
        Both algorithms are quite effective and run in O(E log E) for
        typical implementations, however Prim's can run in O(E + V log
        E) when using Fibonacci heaps and adjacency lists (which I have)
        not done here. Kruskal's also has the very heavy-duty overhead
        however of requiring O(E) storage space, which in this case is
        quadratic in the number of vertices since any pair of vertices
        could be connected.
    </p>
    <p>
        The red bar slowly filling at the top of the left screen
        simulates the generation of the edgelist. Five edges are
        processed per tick to make it bearable for larger sets of
        points.
    </p>
    <p>
        The green lines in the right screen show the internal storage of
        what the closest route to each non-connected node is.
    </p>
</div>
